# 文本重复输出问题分析

## 问题描述

从日志中可以看到，"现在更新 provider 的 Python 代码来实现 OAuth：" 这句话被重复输出了超过1200次（第220行到1444行）。

## 根本原因

在 `main.py` 第130-132行，处理消息文本时没有经过去重处理：

```python
if hasattr(event.content, "text"):
    # 流式输出文本
    print(event.content.text, end="", flush=True)
```

而其他类型的输出（工具调用、工具结果等）都经过了 `IncrementalOutputFormatter` 的处理，具有去重功能。

## 可能的场景

1. **LLM 陷入重复循环**：模型在生成响应时可能陷入了重复模式
2. **流式 API 问题**：每个流式事件都包含了相同的文本片段
3. **缺少去重机制**：普通文本消息没有去重处理

## 修复方案

### 方案 A：添加文本消息去重（推荐）

在 `IncrementalOutputFormatter` 中添加文本去重功能：

```python
class IncrementalOutputFormatter:
    def __init__(self):
        # ... 现有代码 ...
        self.last_message_text = ""  # 记录上次的消息文本
        self.repeat_count = 0  # 记录重复次数
        
    def format_message(self, text: str) -> Optional[str]:
        """格式化消息文本 - 检测并处理重复"""
        if not text:
            return None
            
        # 如果是完全相同的文本
        if text == self.last_message_text:
            self.repeat_count += 1
            # 每50次输出一个提示
            if self.repeat_count % 50 == 0:
                return f"\n[已重复 {self.repeat_count} 次...]\n"
            return None  # 忽略重复
        
        # 如果是新文本，但之前有重复
        if self.repeat_count > 0:
            result = f"\n[上述内容重复了 {self.repeat_count} 次]\n{text}"
            self.repeat_count = 0
        else:
            result = text
            
        self.last_message_text = text
        return result
```

### 方案 B：简单的滑动窗口去重

维护最近N个文本片段，避免短期内的重复：

```python
from collections import deque

class IncrementalOutputFormatter:
    def __init__(self):
        # ... 现有代码 ...
        self.recent_texts = deque(maxlen=10)  # 最近10个文本片段
        
    def format_message(self, text: str) -> Optional[str]:
        """格式化消息文本 - 滑动窗口去重"""
        if not text or text.strip() in self.recent_texts:
            return None
            
        self.recent_texts.append(text.strip())
        return text
```

### 方案 C：基于内容相似度的智能去重

使用更智能的方式检测相似内容：

```python
def format_message(self, text: str) -> Optional[str]:
    """格式化消息文本 - 智能去重"""
    if not text:
        return None
        
    # 标准化文本（去除多余空格、换行等）
    normalized = ' '.join(text.split())
    
    # 检查是否与最近的文本过于相似
    if hasattr(self, 'last_normalized') and normalized == self.last_normalized:
        return None
        
    self.last_normalized = normalized
    return text
```

## 建议实施步骤

1. 实施方案 A（带重复计数），提供更好的用户反馈
2. 在 `main.py` 中使用新的 `format_message` 方法
3. 测试各种重复场景
4. 根据需要调整重复检测的阈值